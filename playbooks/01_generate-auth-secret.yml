# playbooks/01_generate-auth-secret.yml
# üîê Genera el Secret b√°sico cifrado y lo sella con kubeseal
- name: üîê Generar y cifrar Secret del Dashboard
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml

  vars:
    files_dir: "{{ playbook_dir }}/files"
    kubeseal_path: "/usr/local/bin/kubeseal"
    kubectl_path: "/usr/local/bin/kubectl"
    python_bin: "/usr/bin/python3"
    rendered_secret_path: "{{ files_dir }}/longhorn-dashboard-secret.yaml"
    sealed_secret_path: "{{ files_dir }}/longhorn-dashboard-sealed.yaml"
    basic_auth_user: "{{ longhorn_auth_user }}" # Usando las variables del archivo vars/main.yml
    basic_auth_pass: "{{ longhorn_auth_pass }}" # Contrase√±a obtenida desde la variable de entorno

  tasks:
    # Verificaci√≥n de que la variable de entorno LONGHORN_AUTH_PASS est√© definida
    - name: Verificar que la variable de entorno LONGHORN_AUTH_PASS est√© definida
      fail:
        msg: "‚ùå La variable de entorno LONGHORN_AUTH_PASS no est√° definida."
      when: lookup('env', 'LONGHORN_AUTH_PASS') == ""

    # Verificaci√≥n de que la variable de entorno LONGHORN_AUTH_USER est√© definida
    - name: Verificar que la variable de entorno LONGHORN_AUTH_USER est√© definida
      fail:
        msg: "‚ùå La variable de entorno LONGHORN_AUTH_USER no est√° definida."
      when: lookup('env', 'LONGHORN_AUTH_USER') == ""

    # Verificaci√≥n de la instalaci√≥n de kubeseal
    - name: ‚úÖ Verificar que kubeseal est√° instalado
      stat:
        path: "{{ kubeseal_path }}"
      register: kubeseal_check

    - name: ‚ùå Abortamos si kubeseal no est√° instalado
      fail:
        msg: "kubeseal no encontrado en {{ kubeseal_path }}"
      when: not kubeseal_check.stat.exists

    # Verificaci√≥n de la instalaci√≥n de kubectl
    - name: ‚úÖ Verificar que kubectl est√° instalado
      stat:
        path: "{{ kubectl_path }}"
      register: kubectl_check

    - name: ‚ùå Abortamos si kubectl no est√° instalado
      fail:
        msg: "kubectl no encontrado en {{ kubectl_path }}"
      when: not kubectl_check.stat.exists

    # Crear el directorio de archivos de Secrets si no existe
    - name: üìÅ Crear directorio local para secrets si no existe
      file:
        path: "{{ files_dir }}"
        state: directory
        mode: "0755"

    # Generar hash de la contrase√±a usando htpasswd (basicAuth con MD5)
    - name: üîê Generar hash htpasswd (basicAuth con MD5)
      command: >
        {{ python_bin }} -c "import crypt; print('{{ basic_auth_user }}:' + crypt.crypt('{{ basic_auth_pass }}', crypt.mksalt(crypt.METHOD_MD5)))"
      register: htpasswd_output
      changed_when: true
      failed_when: htpasswd_output.rc != 0 or htpasswd_output.stdout == ""

    # Codificar el hash en base64
    - name: üîê Codificar el hash en base64
      set_fact:
        basic_auth: "{{ htpasswd_output.stdout | b64encode }}"

    # Renderizar el Secret para la autenticaci√≥n b√°sica
    - name: üìÑ Renderizar plantilla Secret
      template:
        src: ../templates/secrets/basic-auth-secret.yaml.j2
        dest: "{{ rendered_secret_path }}"
      vars:
        namespace_tpl: "{{ longhorn_namespace }}"
        basic_auth: "{{ basic_auth }}"

    # Sellar el Secret con kubeseal
    - name: üîê Sellar con kubeseal ‚Üí YAML
      shell: >
        {{ kubeseal_path }} \
        --kubeconfig {{ kubeconfig_path }} \
        --format yaml < "{{ rendered_secret_path }}" > "{{ sealed_secret_path }}"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      args:
        executable: /bin/bash

    # Aplicar el Secret sellado
    - name: üöÄ Aplicar Secret Sellado de Autenticaci√≥n
      command: >
        {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }} apply -f "{{ sealed_secret_path }}"
      when: not ansible_check_mode # Solo en modo ejecuci√≥n real

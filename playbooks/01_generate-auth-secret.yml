# playbooks/01_generate-auth-secret.yml
# 🔐 Genera el Secret básico, lo sella con kubeseal e instala el SealedSecret
---
- name: 🔐 Generar y cifrar Secret del Dashboard
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml         # ← debe contener longhorn_auth_user / pass

  vars:
    files_dir: "{{ playbook_dir }}/files"
    rendered_secret_path: "{{ files_dir }}/longhorn-dashboard-secret.yaml"
    sealed_secret_path:   "{{ files_dir }}/longhorn-dashboard-sealed.yaml"

  pre_tasks:
    - name: 🚧 Comprobamos prerequisitos binarios
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - "{{ kubeseal_path }}"
        - "{{ kubectl_path }}"
      register: prereq
      failed_when: not prereq.results | map(attribute='stat.exists') | min

    - name: 🚧 Comprobamos credenciales requeridas
      assert:
        that:
          - longhorn_auth_user | length > 0
          - longhorn_auth_pass | length > 0
        fail_msg: "Definir LONGHORN_AUTH_USER y LONGHORN_AUTH_PASS (variables o entorno)"

  tasks:
    - name: 📁 Asegurar directorio «files»
      file:
        path: "{{ files_dir }}"
        state: directory
        mode: "0755"

    - name: 🔐 Generar registro htpasswd (bcrypt)
      community.general.htpasswd:
        path: /tmp/longhorn_htpasswd
        name: "{{ longhorn_auth_user }}"
        password: "{{ longhorn_auth_pass }}"
        crypt_scheme: bcrypt   # Traefik lo soporta y es fuerte
      register: htpasswd_file
      changed_when: htpasswd_file.changed

    - name: 🔐 Leer hash generado
      slurp:
        src: /tmp/longhorn_htpasswd
      register: slurp_htpasswd
      when: htpasswd_file.changed

    - name: 🔐 Codificar «user:hash» en base64
      set_fact:
        basic_auth: "{{ (slurp_htpasswd.content | b64decode | trim) | b64encode }}"

    - name: 📄 Renderizar plantilla Secret
      ansible.builtin.template:
        src: ../templates/secrets/basic-auth-secret.yaml.j2
        dest: "{{ rendered_secret_path }}"
      vars:
        namespace_tpl: "{{ longhorn_namespace }}"
        basic_auth:     "{{ basic_auth }}"

    - name: 🔐 Sellar con kubeseal → YAML
      ansible.builtin.command:
        cmd: >
          {{ kubeseal_path }}
          --kubeconfig {{ kubeconfig_path }}
          --format yaml
          < {{ rendered_secret_path }}
      register: sealed_out
      changed_when: "'sealedsecret' in sealed_out.stdout.lower()"

    - name: 💾 Guardar SealedSecret en disco
      copy:
        content: "{{ sealed_out.stdout }}"
        dest: "{{ sealed_secret_path }}"

    - name: 🚀 Aplicar SealedSecret
      ansible.builtin.command:
        cmd: >
          {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
          apply -f {{ sealed_secret_path }}
      changed_when: "'created' in result.stdout or 'configured' in result.stdout"
      register: result
